
# Chat Widget Integration Guide

This guide provides instructions on how to integrate and configure the `ChatWidget` component, `useChatSocket` hook, and the required backend services.

## 1. Environment Configuration

The chat system's behavior is controlled by environment variables in `.env.local`.

### Switching Between Mock and Production

-   **To use the mock in-memory backend:**
    Create a `.env.local` file in your project root and add:
    ```
    NEXT_PUBLIC_USE_MOCK=true
    ```
-   **To connect to the live Socket.io backend:**
    Ensure the variable is `false` or removed, and define the socket and API URLs:
    ```
    NEXT_PUBLIC_USE_MOCK=false
    NEXT_PUBLIC_SOCKET_URL=https://your-socket-server.com
    NEXT_PUBLIC_API_URL=https://your-api-server.com/api
    ```

## 2. Authentication with Socket.io

The `useChatSocket` hook is set up to easily pass an authentication token during the socket connection handshake. This is critical for securing your chat.

### Example with NextAuth.js or JWT

You'll need to get the user's token from your authentication provider and pass it in the `auth` option of the `io` constructor.

Modify `src/hooks/useChatSocket.js`:

```javascript
// Inside the useEffect hook
import { useSession } from "next-auth/react"; // Example for NextAuth

// ... inside your component or another hook that wraps useChatSocket
const { data: session } = useSession();
const token = session?.accessToken; // Adjust based on your session structure

// ... inside useChatSocket.js's useEffect
socketRef.current = io(socketUrl, {
  query: { roomId: resolvedRoomId },
  // Pass the token here
  auth: {
    token: your_auth_token_variable, // e.g., token from useSession
  },
});
```

On your **Socket.io server**, you would then have middleware to verify this token before allowing the connection to proceed.

## 3. Required REST API Endpoints

The chat widget relies on two REST endpoints for features not handled by WebSockets.

### A. Message History

-   **Endpoint**: `GET /messages/{roomId}`
-   **Description**: Fetches the historical messages for a given chat room.
-   **Request**:
    -   URL Param: `roomId` (string)
-   **Successful Response** (`200 OK`):
    -   Content-Type: `application/json`
    -   Body: An array of message objects.
        ```json
        [
          {
            "id": "msg-12345",
            "roomId": "user1--user2",
            "senderId": "user1",
            "type": "text",
            "text": "Hello, world!",
            "timestamp": "2023-10-27T10:00:00Z"
          },
          {
            "id": "msg-12346",
            "roomId": "user1--user2",
            "senderId": "user2",
            "type": "file",
            "file": {
              "url": "https://your-cdn.com/files/document.pdf",
              "name": "document.pdf",
              "size": 102400
            },
            "timestamp": "2023-10-27T10:01:00Z"
          }
        ]
        ```

### B. File Upload

-   **Endpoint**: `POST /upload`
-   **Description**: Handles file uploads and returns a public URL for the file.
-   **Request**:
    -   Content-Type: `multipart/form-data`
    -   Body: Form data containing the `file`.
-   **Successful Response** (`200 OK`):
    -   Content-Type: `application/json`
    -   Body: A JSON object with the URL of the uploaded file.
        ```json
        {
          "url": "https://your-cdn.com/files/unique-file-name.ext"
        }
        ```

## 4. Socket.io Events

The client and server communicate using a standard set of events.

-   `joinRoom` (Client to Server)
    -   **Payload**: `string` (the `roomId`)
    -   **Action**: Tells the server to subscribe this client's socket to a specific room to receive targeted messages.

-   `sendMessage` (Client to Server)
    -   **Payload**: `object` (the message object, without `id` or `timestamp`)
    -   **Action**: Sends a new message to the server, which then broadcasts it to the other members of the room.

-   `receiveMessage` (Server to Client)
    -   **Payload**: `object` (the complete message object, including server-generated `id` and `timestamp`)
    -   **Action**: Informs the client that a new message has been received.

-   `typing` (Client to Server) (Optional, not implemented in current UI)
    -   **Payload**: `{ roomId: string, isTyping: boolean }`
    -   **Action**: Can be used to show a "user is typing..." indicator.

-   `messageRead` (Client to Server) (Optional, not implemented in current UI)
    -   **Payload**: `{ roomId: string, messageId: string }`
    -   **Action**: Can be used to implement read receipts.

## 5. Suggested Message Schema

A consistent message shape is crucial. The following JSON structure is recommended:

```json
{
  "id": "string", // Unique ID (e.g., UUID, generated by server)
  "roomId": "string", // ID of the chat room
  "senderId": "string", // ID of the user who sent the message
  "timestamp": "string", // ISO 8601 timestamp
  "type": "string", // 'text' | 'file' | 'image'
  "text": "string | null", // Message content if type is 'text'
  "file": {
    "url": "string", // URL to the uploaded file
    "name": "string", // Original file name
    "size": "number" // File size in bytes
  } | null,
  "status": "string | null" // Optional client-side status: 'sending', 'sent', 'failed'
}
```

---

## 6. Unit Test Recommendations

For testing, we recommend using **Jest** and **React Testing Library**.

### Setup

1.  Install dependencies:
    `npm install --save-dev jest @testing-library/react @testing-library/jest-dom jest-environment-jsdom`
2.  Configure Jest (e.g., in `jest.config.js`).

### Sample Test: Optimistic UI Update

This test verifies that when a user sends a message, it appears in the UI immediately, even before the mock socket "responds".

**`__tests__/ChatWidget.test.jsx`**

```javascript
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import { ChatWidget } from '../components/chat/ChatWidget';
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';

dayjs.extend(relativeTime);

// Mock the custom hook to control its output
jest.mock('../hooks/useChatSocket', () => ({
  useChatSocket: () => ({
    messages: [], // Start with no messages
    sendMessage: jest.fn(), // Mock the send function
    connected: true, // Assume connection is active
  }),
}));

// Mock dayjs to return a consistent value
jest.mock('dayjs', () => {
  const originalDayjs = jest.requireActual('dayjs');
  originalDayjs.extend(jest.requireActual('dayjs/plugin/relativeTime'));
  const mockDayjs = (time) => originalDayjs(time); // Keep original constructor
  mockDayjs.fromNow = () => 'just now'; // Mock only fromNow
  return (time) => ({ ...mockDayjs(time), fromNow: () => 'just now' });
});


describe('ChatWidget', () => {
  it('optimistically displays a sent message', async () => {
    render(<ChatWidget userId="user1" otherId="user2" title="Test Chat" />);

    // 1. Find the input and type a message
    const messageInput = screen.getByPlaceholderText('Type a message...');
    fireEvent.change(messageInput, { target: { value: 'Hello there!' } });

    // 2. Find and click the send button
    const sendButton = screen.getByRole('button', { name: /send/i });
    fireEvent.click(sendButton);

    // 3. Check if the message appears in the document
    // This is the optimistic update. The mock `useChatSocket` hook hasn't
    // returned this message yet; the component added it to its state directly.
    const sentMessage = await screen.findByText('Hello there!');
    expect(sentMessage).toBeInTheDocument();

    // 4. Verify the input is cleared after sending
    expect(messageInput.value).toBe('');

    // 5. Check if the message has the 'sent' class for correct styling
    // We traverse up to the List.Item element to find the className
    const messageListItem = sentMessage.closest('.ant-list-item');
    expect(messageListItem).toHaveClass('sent');
  });
});
```
